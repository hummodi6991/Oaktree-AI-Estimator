name: Deploy to sccc (Alibaba Cloud Riyadh)

on:
  push:
    branches: [ "main" ]
    paths:
      - "app/**"
      - "alembic/**"
      - "frontend/**"
      - "Dockerfile"
      - ".github/workflows/deploy-sccc.yml"
      - "k8s/**"
      - "sql/**"
      - "models/**"
      - "Makefile"
  workflow_dispatch:

permissions:
  contents: read

env:
  ALIBABA_REGION: ${{ vars.ALIBABA_REGION }}            # e.g., me-central-1
  ACR_INSTANCE_ID: ${{ secrets.ALIBABA_CLOUD_ACR_INSTANCE_ID }}  # e.g., cri-xxxxxxxx
  ACR_NAMESPACE: ${{ vars.ACR_NAMESPACE }}              # e.g., oaktree
  SERVICE_NAME: ${{ vars.SERVICE_NAME }}                # e.g., oaktree-estimator
  ACK_CLUSTER_ID: ${{ vars.ACK_CLUSTER_ID }}            # e.g., c5b5e80b0b64a4bf...
  ACR_LOGIN_SERVER: ${{ vars.ACR_LOGIN_SERVER }}        # e.g., oaktree-ai-estimator-registry.me-central-1.cr.aliyuncs.com

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 1) Tooling
      - name: Install CLI tooling (aliyun, kubectl, jq)
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          curl -fsSL https://aliyuncli.alicdn.com/aliyun-cli-linux-latest-amd64.tgz -o aliyun.tgz
          tar -xzf aliyun.tgz && sudo mv aliyun /usr/local/bin/aliyun
          curl -L -o kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/kubectl

      # Normalize registry host (strip scheme, CR/LF, trailing slashes)
      - name: Normalize ACR registry host
        id: reg
        run: |
          R="${ACR_LOGIN_SERVER}"
          R="${R#http://}"; R="${R#https://}"
          R="$(printf '%s' "$R" | tr -d '\r' | tr -d '\n' | sed 's:/*$::')"
          echo "host=$R" >> "$GITHUB_OUTPUT"
          echo "ACR_REG_HOST=$R" >> "$GITHUB_ENV"

      # Normalize namespace and service (strip CR/LF, spaces, trailing slashes)
      - name: Normalize image coordinates
        id: imgmeta
        run: |
          NS="$(printf '%s' "${ACR_NAMESPACE}" | tr -d '\r\n' | tr -d ' ' | sed 's:/*$::')"
          SVC="$(printf '%s' "${SERVICE_NAME}" | tr -d '\r\n' | tr -d ' ' | sed 's:/*$::')"
          echo "ns=$NS"  >> "$GITHUB_OUTPUT"
          echo "svc=$SVC" >> "$GITHUB_OUTPUT"
          echo "ACR_NS=$NS" >> "$GITHUB_ENV"
          echo "SVC_NAME=$SVC" >> "$GITHUB_ENV"
      # 2) Configure Alibaba Cloud credentials (AK/SK workaround until OIDC is enabled)
      - name: Configure Alibaba Cloud credentials
        run: |
          aliyun configure set \
            --mode AK \
            --access-key-id "${{ secrets.ALIBABA_ACCESS_KEY_ID }}" \
            --access-key-secret "${{ secrets.ALIBABA_ACCESS_KEY_SECRET }}" \
            --region "${{ env.ALIBABA_REGION }}"

      # 3) Ephemeral ACR login (token from ACR API)
      - name: Get temporary ACR login (STS)
        id: acr
        run: |
          # Fetch a short-lived Docker username/password for ACR EE (no --output flags)
          JSON=$(aliyun cr GetAuthorizationToken --RegionId "$ALIBABA_REGION" --InstanceId "$ACR_INSTANCE_ID")
          # Support multiple response shapes
          ACR_USER=$(echo "$JSON" | jq -r '.TempUsername // .tempUserName // .data.tempUserName // .data.TempUsername')
          ACR_PASS=$(echo "$JSON" | jq -r '.AuthorizationToken // .authorizationToken // .data.authorizationToken // .data.AuthorizationToken')
          if [ -z "$ACR_USER" ] || [ -z "$ACR_PASS" ]; then
            echo "Failed to parse ACR token response" >&2
            echo "$JSON" | jq -r 'del(.AuthorizationToken,.data.authorizationToken)' >&2
            exit 1
          fi
          echo "acr_username=$ACR_USER" >> "$GITHUB_OUTPUT"
          echo "acr_password=$ACR_PASS" >> "$GITHUB_OUTPUT"

      - name: Docker login to ACR
        run: echo "${{ steps.acr.outputs.acr_password }}" | docker login "${{ steps.reg.outputs.host }}" -u "${{ steps.acr.outputs.acr_username }}" --password-stdin

      # 4) Build & push Docker image to ACR
      - name: Free disk space on runner
        run: |
          df -h
          sudo rm -rf /usr/local/lib/android /opt/ghc /opt/hostedtoolcache || true
          docker system prune -af || true
          df -h

      - name: Build & push image
        id: img
        run: |
          IMAGE="${ACR_REG_HOST}/${ACR_NS}/${SVC_NAME}:${{ github.sha }}"
          echo "Using image: $IMAGE"
          docker build --build-arg VITE_PARCEL_TILE_TABLE=public.ms_buildings_raw -t "$IMAGE" .
          docker push "$IMAGE"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      # 5) Fetch kubeconfig for the ACK cluster
      - name: Get kubeconfig for ACK
        id: kube
        run: |
          aliyun cs DescribeClusterUserKubeconfig --RegionId "$ALIBABA_REGION" --ClusterId "$ACK_CLUSTER_ID" | jq -r '.config' > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      # 6) Create/Update Secrets (oaktree-db-env / oaktree-app-env)
      - name: Create/Update DB Secret (oaktree-db-env)
        run: |
          kubectl create secret generic oaktree-db-env \
            --from-literal=POSTGRES_USER="${{ secrets.POSTGRES_USER }}" \
            --from-literal=POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
            --from-literal=POSTGRES_DB="${{ secrets.POSTGRES_DB }}" \
            --from-literal=POSTGRES_HOST="${{ secrets.POSTGRES_HOST }}" \
            --from-literal=POSTGRES_PORT="${{ secrets.POSTGRES_PORT }}" \
            --from-literal=PGSSLMODE=require \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update App Secret (oaktree-app-env)
        run: |
          kubectl create secret generic oaktree-app-env \
            --from-literal=APP_ENV=prod \
            --from-literal=AUTH_MODE=disabled \
            --from-literal=PARCEL_TILE_TABLE=public.ms_buildings_raw \
            --from-literal=PARCEL_IDENTIFY_TOLERANCE_M=75 \
            --from-literal=PARCEL_IDENTIFY_TABLE=public.ms_buildings_raw \
            --from-literal=PARCEL_IDENTIFY_GEOM_COLUMN=geom \
            --from-literal=PARCEL_TARGET_SRID=4326 \
            --from-literal=PARCEL_ENVELOPE_PAD_M=5 \
            --from-literal=PARCEL_SIMPLIFY_TOLERANCE_M=1 \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Run DB migrations (alembic)
        run: |
          set -euo pipefail

          kubectl delete job/oaktree-migrate --ignore-not-found=true

          cat > migrate-job.yml <<'YAML'
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: oaktree-migrate
          spec:
            backoffLimit: 0
            ttlSecondsAfterFinished: 3600
            template:
              spec:
                restartPolicy: Never
                containers:
                  - name: migrate
                    image: ${{ steps.img.outputs.image }}
                    command: ["alembic", "upgrade", "head"]
                    envFrom:
                      - secretRef:
                          name: oaktree-db-env
                      - secretRef:
                          name: oaktree-app-env
                    env:
                      - name: DB_DEBUG
                        value: "1"
          YAML

          kubectl apply -f migrate-job.yml

          kubectl wait -n default --for=condition=complete --timeout=1800s job/oaktree-migrate || true
          kubectl describe job oaktree-migrate -n default || true
          kubectl get pods -n default -l job-name=oaktree-migrate -o wide || true

          PODS=$(kubectl get pods -n default -l job-name=oaktree-migrate -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || true)
          for POD in $PODS; do
            echo "--- Logs for pod: $POD" || true
            kubectl logs -n default "$POD" --all-containers --tail=400 || true
            kubectl logs -n default "$POD" --previous --all-containers --tail=400 || true
            kubectl describe pod -n default "$POD" || true
          done

          JOB_COMPLETE=$(kubectl get job oaktree-migrate -n default -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}' 2>/dev/null || true)
          if [ "$JOB_COMPLETE" != "True" ]; then
            exit 1
          fi

      # 7) Deploy to ACK (patch image and apply)
      - name: Validate manifests (dry-run)
        run: |
          kubectl apply --dry-run=client -f k8s/

      - name: Deploy manifests
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ steps.img.outputs.image }}|g" k8s/deployment.yaml
          kubectl apply -f k8s/
